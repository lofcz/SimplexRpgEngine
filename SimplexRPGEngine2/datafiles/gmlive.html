<html><head>
<meta charset="UTF-8">
<title>GMLive.gml cheat sheet</title>
<style type="text/css">
html {
	background-color: #f9f9f9;
}
body, #doc tt {
	font: 15px 'Open Sans', sans-serif;
	line-height: 1.35;
}
body {
	max-width: 640px;
	background: #ffffff;
	margin: 0 auto;
	padding: 8px;
	box-shadow: 0 0 0 2px #eee;
}

#doc, #doc ul {
	padding-left: 0;
	margin: 0;
}
#doc div ul, #doc div ol {
	padding-left: 20px;
}
#doc div ul li {
	list-style: disc;
	list-style-image: url('data:image/svg+xml;base256,<?xml version="1.0" encoding="UTF-8"?><svg xmlns="http://www.w3.org/2000/svg" width="20px" height="1em" viewBox="0 0 20px 1em"><circle cx="17px" cy="0.675em" r="2px"/></svg>'); 
}

#doc .header {
	display: block;
	outline: none;
	text-decoration: none;
	margin: 0;
	font-weight: 700;
	font-size: 100%;
	color: #458;
	border-left: 2px solid #f3f3f3;/* #f9f9f9*/
	padding-left: 4px;
	padding-top: 1px;
	padding-bottom: 1px;
	cursor: pointer;
}
#doc .header::before {
	display: inline-block;
	content: "+";
	font: 12px monospace;
	border: 1px solid #458;
	line-height: 11px;
	height: 11px;
	width: 11px;
	text-align: center;
	border-radius: 50%;
	margin-right: 4px;
	vertical-align: middle;
	position: relative;
	top: -1px;
}
#doc .item.open > .header::before {
	content: "-";
}
#doc .header:hover {
	border-left-color: #f3f3f3;
	background: #f3f3f3;
}

#doc a.broken {
	color: red;
}
#doc p {
	margin: 0;
}
#doc p + p, #doc p.pad {
	margin-top: 0.5em;
}

#doc .content, #doc ul {
	padding-left: 20px;
	border-left: 2px solid #f3f3f3;
}
#doc tt {
	font-weight: bold;
}
#doc pre {
	font-family: Consolas, Dejavu Sans Mono, Segoe UI Mono, Ubuntu Mono, Lucida Console, monospace;
	font-size: 9pt;
	line-height: 1.25;
	background: white;
	padding: 4px 2px 4px 10px;
	margin: 0;
	tab-size: 4;
	overflow-x: auto;
	white-space: pre-wrap;
	word-break: break-all;
}
#doc pre a {
	text-decoration: none;
}
#doc pre a.uf {
	background-color: #f7f0ff;
}
#doc pre a.kw {
	background-color: #f0f7ff;
}
#doc pre a.sf, #doc pre a.sv {
	background-color: #fff3f0;
}
#doc pre a:hover {
	text-decoration: underline;
}
#doc abbr[title] {
	text-decoration: underline;
	text-decoration-color: #bbb;
	text-decoration-style: double;
}
/* delay display until load */
#doc[ready] .item:not(.open) > .content {
	display: none;
}
</style>
<style type="text/css" id="md_gml">
/* GameMakerLanguage */
pre.gmlmd .md { color: #808 } /* #define */
pre.gmlmd .kw { color: #008; font-weight: bold } /* keyword */
pre.gmlmd .co { color: #080 } /* comment */
pre.gmlmd .nu { color: #00f } /* number */
pre.gmlmd .nx { color: #00f } /* hex */
pre.gmlmd .st { color: #00f } /* string */
pre.gmlmd .ts { color: #00f } /* template string */
pre.gmlmd .op { color: #000 } /* operator */
pre.gmlmd .cb { color: #008; font-weight: bold } /* curly brace */
pre.gmlmd .sv { color: #800 } /* std func */
pre.gmlmd .sf { color: #800 } /* std var */
pre.gmlmd .ri { color: #0078aa } /* assets */
pre.gmlmd .uf { color: #808 } /* user func */
pre.gmlmd .uv { color: #000 } /* user var */
pre.gmlmd .lv { color: #648 } /* local var */
pre.gmlmd .fd { color: #804 } /* field */
</style>
<noscript><style>
#doc .header::before {
	display: none;
}
#doc .header:hover {
	border-left-color: #f3f3f3;
	background: inherit;
}
#doc { display: inherit }
#doc .item:not(.open) > .content {
	display: inherit;
}
</style></noscript>
</head><body><p>
This is a "cheat sheet" for GMLive.gml extension by YellowAfterlife.<br>
The extension can be acquired from
	<a href="https://marketplace.yoyogames.com/assets/5992/_">GM:Marketplace</a>
	or <a href="https://yellowafterlife.itch.io/gamemaker-live">itch.io</a>.<br>
For questions/support, use <a href="https://yellowafterlife.itch.io/gamemaker-live/community">forums</a>, or <a href="mailto://yellowafterlife@hotmail.com">send me an email</a>.<br>
An up-to-date version of this document can always be found <a href="https://yal.cc/r/17/gmlive">online</a>.
</p><p>
Click on sections to expand/collapse them.<br>
Quick display controls: <a href="#" onclick="opt_none(); return false">Categories</a>
&middot; <a href="#" onclick="opt_list(); return false">Functions</a>
&middot; <a href="#" onclick="opt_all(); return false">Everything</a>
</p><div id="doc">
<!--<doc--><div class="item"><a class="header" id="use1" href="#use1" title="(permalink)">Using GMLive.gml in GMS1</a><div class="content"><p>
	<div class="item"><a class="header" id="gms1-setup" href="#gms1-setup" title="(permalink)">Initial setup</a><div class="content"><p>
		Setting up is as following:
		</p><ul>
			<li>	Make sure that you are running an up-to-date version of GameMaker: Studio.
				<br/>You can find links to all versions at <a href="https://www.yoyogames.com/downloads/gm-studio/release-notes-studio.html">official website</a>.
			</li><li>	Import the GMLive extension to the project.
				<br/>With GMEZ file, either right-click on "Extensions" category in project tree and pick "import extension", or just drag-and-drop the file onto IDE from Explorer.
			</li><li>	Import the assets (included files and <tt>obj_gmlive</tt>) from the package.
				<br/>To do so, right-click on the extension, pick "Properties", and use the "Import" tab.
				<br/>Depending on factors, it can take GMS1 a bit of time to show the dialog.
				<br/>If it's stuck for good, use 7-zip (or equivalent) to unpack the GMEZ file, and import the assets (contents of "datafiles" directory and obj_gmlive.object.gmx) via dragging and dropping them onto IDE.
			</li><li>	Place <tt>obj_gmlive</tt> in the first room of the project.
			</li><li>	Open menu "Resources - Define Macros" (Ctrl+Shift+N) and add a macro called <tt>live_enabled</tt> with value <tt>1</tt>.
		</li></ul><p class="pad">
		
		Now, as you might know, GMS1 does not let you save project while the game is running on most targets. This can be solved in multiple ways:
		</p><p>
		<strong>A.</strong> Use <strong>netlog</strong> and <strong>GMLiveHelper</strong> extensions (when on Windows): </p><ul>
			<li>	Right-click on <strong>netlog.gmez</strong> in Included Files and pick "Open in Explorer".
			</li><li>	Import <strong>netlog.gmez</strong> and <strong>GMLiveHelper.gmez</strong> to the project (much like above).
			</li><li>	When starting up <strong>gmlive-server</strong>, also run <strong>netlog.exe</strong> in Included Files.
			</li><li>	Use <tt>netlog</tt> script for debug logging instead of <tt>show_debug_message</tt>.
				<br/>(which will display text in netlog's window when connected or IDE when not)
		</li></ul><p class="pad">
		
		<strong>B.</strong> Compile and run the game instead of running it from IDE directly.
		</p><p>
		<strong>C.</strong> Use an external editor for changing the "live" files mid-game: </p><ul>
			<li>	There's a large number of editors that can be used for this - from specialized ones like Parakeet 2 to ones with GML plugins (Notepad++, Sublime Text, Visual Studio Code, etc.) to even general-purpose ones (e.g. JS or C# syntax highlighting works well enough for GML).
			</li><li>	This can be faster than other options because an external editor will only re-save the file in question while saving the project in GMS1 always also re-saves the .project.gmx (and makes a backup if you didn't disable "backup on save" in File - Preferences).
			</li><li>	The file(s) in question should not be open in GM:S while you are editing them externally, or GMS1 might overwrite them with additional version next time you save the project. If things happen, copy the updated code from external editor back to GM:S.
		</li></ul><p class="pad">
		
		Once you are done setting things up, you can remove <strong>netlog.gmez</strong> and <strong>GMLiveHelper.gmez</strong> from Included Files.
		</p><p>
		If you have <a href="http://nekovm.org/download">Neko VM</a> installed, you can also remove all DLL and NDLL files.
		</p><p>
		If you are not using option A, you can also remove <strong>netlog.exe</strong> and remove the <tt>live_restart_if_necessary</tt> line from <tt>obj_gmlive</tt>'s Create event.
		</p><p>
		(you can always re-import the included files later on)
	</p></div></div>
	<div class="item"><a class="header" id="gms1-start" href="#gms1-start" title="(permalink)">Starting up</a><div class="content"><p>
		</p><ul>
			<li>	Double-click <tt>gmlive-server.exe</tt> in Included Files to run it.
				<br/>You can leave it running when recompiling the game - it will re-scan the project directory whenever a new game instance connects to it.
			</li><li>	If you've installed GMLiveHelper, also double-click <tt>netlog.exe</tt>.
				<br/>Similarly, can be left running between game sessions.
			</li><li>	Add <a href="#api-live">live function calls</a> to scripts and events of interest.
				<br/>Note that for events the live-call must be in the first block of the event (since GMS simply combines them during compilation), and there may not be non-"Execute code" DnD blocks in the event.
			</li><li>	Run the game.
			</li><li>	Change the "live" scripts/events as you see fit and see the changes in-game (if everything was done correctly). gmlive-server' window will report status updates.
		</li></ul><p>
	</p></div></div>
	<div class="item"><a class="header" id="gms1-export" href="#gms1-export" title="(permalink)">Exporting</a><div class="content"><p>
		Usually you do not want non-development builds of the game to periodically ping a local or non-local address - while not exactly resource-intensive, this may raise warnings on some firewalls and anti-virus software.
		</p><p>
		For that reason it is suggested that you disable GMLive prior to exporting.
		</p><p>
		To do so, open menu "Resources - Define Macros" (Ctrl+Shift+N), and change the value of previously defined <tt>live_enabled</tt> macro to <tt>0</tt>.
		</p><p>
		This will disable the logic inside all of GMLive's scripts and return default values, having it that nothing will happen when calling them, and that they will not influence compile times/output size much as such.
		</p><p>
		After exporting you can set <tt>live_enabled</tt> back to <tt>1</tt>.
	</p></div></div>
</p></div></div>
<div class="item"><a class="header" id="use2" href="#use2" title="(permalink)">Using GMLive.gml in GMS2</a><div class="content"><p>
	<div class="item"><a class="header" id="gms2-setup" href="#gms2-setup" title="(permalink)">Initial setup</a><div class="content"><p>
		</p><ul>
			<li>	Import the GMLive asset the project.
				<br/>(with itch.io, you need to drag the <tt>.yymp</tt> file onto the workspace area)
			</li><li>	Import the assets (extension, object, and included files) from the package.
			</li><li>	Place <tt>obj_gmlive</tt> in the first room of the project.
		</li></ul><p>
	</p></div></div>
	<div class="item"><a class="header" id="gms2-start" href="#gms2-start" title="(permalink)">Starting up</a><div class="content"><p>
		</p><ul>
			<li>	Right-click <tt>gmlive-server.exe</tt> in Included Files, pick "Open in Explorer"
				<br/>(likely named "Open in Finder" on Mac)
			</li><li>	On Windows, double-click the gmlive-server executable.
				<br/>On Mac, open Terminal in the directory and do <tt>neko gmlive-server.n</tt> (see <a href="#gmlive-server">gmlive-server</a> for more information).
				<br/>You can leave it running when recompiling the game - it will re-scan the project directory whenever a new game instance connects to it.
			</li><li>	Add <a href="#api-live">live function calls</a> to scripts and events of interest.
				<br/>Note that for events the live-call must be in the first block of the event (since GMS simply combines them during compilation), and there may not be non-"Execute code" DnD blocks in the event.
			</li><li>	Run the game.
			</li><li>	Change the "live" scripts/events as you see fit and see the changes in-game (if everything was done correctly). gmlive-server' window will report status updates.
		</li></ul><p>
	</p></div></div>
	<div class="item"><a class="header" id="gms2-export" href="#gms2-export" title="(permalink)">Exporting</a><div class="content"><p>
		Usually you do not want non-development builds of the game to periodically ping a local or non-local address - while not exactly resource-intensive, this may raise warnings on some firewalls and anti-virus software.
		</p><p>
		For that reason it is suggested that you disable GMLive prior to exporting.
		</p><p>
		To do so, change the value of <tt>live_enabled</tt> macro in <tt>obj_gmlive</tt>'s Create event to <tt>0</tt>.
		</p><p>
		This will disable the logic inside all of GMLive's scripts and return default values, having it that nothing will happen when calling them, and that they will not influence compile times/output size much as such.
		</p><p>
		After exporting you can set <tt>live_enabled</tt> back to <tt>1</tt>.
	</p></div></div>
</p></div></div>
<div class="item"><span class="header">General functions</span><div class="content"><p>
	<div class="item"><a class="header" id="live_init" href="#live_init" title="(permalink)">live_init(update_rate, url, password)</a><div class="content"><p>
		<tt>update_rate</tt> is how often files should be checked for updates, in seconds. <tt>1</tt> is a common value. Lower values can load changed files faster, but will also cause file system to be polled more frequently.
		</p><p>
		<tt>url</tt> is the URL that gmlive-server is running on. Most often you would have this as <tt>"http://127.0.0.1:5100"</tt> to connect to the server on the same machine.
		</p><p>
		<tt>password</tt> is the password set via gmlive-server' <tt>--password</tt> option, as a basic form of security if running the server in an unprotected network. If you did not specify one, this should be left as a blank string.
	</p></div></div>
	<div class="item"><a class="header" id="live_log_script" href="#live_log_script" title="(permalink)">live_log_script</a><div class="content"><p>
		Can be assigned to a script that GMLive will call to display debug information (such as notifications about scripts being reloaded), e.g.
		<br/></p><pre class="gmlmd">
<a class="sv" href="#live_log_script">live_log_script</a> <span class="op">=</span> <span class="uf">scr_log</span><span class="op">;</span>
</pre><p>If not assigned, plain <tt>show_debug_message</tt> calls are used.
	</p></div></div>
	<div class="item"><a class="header" id="live_execute_string" href="#live_execute_string" title="(permalink)">live_execute_string(gml_code)</a><div class="content"><p>
		Attempts to compile and run a snippet of GML code.
		</p><p>
		Returns whether execution succeeded. If it did, <tt>live_result</tt> contains the returned value (if any). If it didn't, <tt>live_result</tt> contains the error text.
		<br/></p><pre class="gmlmd">
<span class="kw">if</span> <span class="op">(</span><a class="sf" href="#live_execute_string">live_execute_string</a><span class="op">(</span><span class="op">@</span><span class="st">'show_message("Hello!"); return 1'</span><span class="op">)</span><span class="op">)</span> <span class="cb">{</span>
	<span class="sf">show_debug_message</span><span class="op">(</span><span class="st">"Result: "</span> <span class="op">+</span> <span class="uf">string</span><span class="op">(</span><a class="sv" href="#live_result">live_result</a><span class="op">)</span><span class="op">)</span><span class="op">;</span>
<span class="cb">}</span> <span class="kw">else</span> <span class="sf">show_debug_message</span><span class="op">(</span><span class="st">"Error: "</span> <span class="op">+</span> <span class="uf">string</span><span class="op">(</span><a class="sv" href="#live_result">live_result</a><span class="op">)</span><span class="op">)</span><span class="op">;</span>
</pre><p>Please keep in mind that much like the similarly-named GM&lt;=8.1 function, this compiles code on every call, thus is not fast and should only be used for debugging (e.g. if you want to be able to type snippets of GML in-game for quick tests).
	</p></div></div>
</p></div></div>
<div class="item"><a class="header" id="api-live" href="#api-live" title="(permalink)">Live functions</a><div class="content"><p>
	<div class="item"><a class="header" id="live_call" href="#live_call" title="(permalink)">live_call(...arguments)</a><div class="content"><p>
		Calls the "live" version of the current script/event with specified arguments (if any).
		</p><p>
		Returns whether the "live" version is already loaded and was called.
		</p><p>
		If execution succeeds, <a href="#live_result">live_result</a> contains the returned value.
		</p><p>
		If execution fails, <a href="#live_result">live_result</a> contains <tt>0</tt> (also see <a href="#live_defcall">live_defcall</a>).
		</p><p>
		For example, if your script takes no arguments, you could do:
		<br/></p><pre class="gmlmd">
<span class="co">/// scr_test</span>
<span class="kw">if</span> <span class="op">(</span><a class="sf" href="#live_call">live_call</a><span class="op">(</span><span class="op">)</span><span class="op">)</span> <span class="kw">return</span> <a class="sv" href="#live_result">live_result</a><span class="op">;</span>
<span class="kw">return</span> <span class="st">"Hello!"</span><span class="op">;</span>
</pre><p>If your script takes two arguments, you could do:
		<br/></p><pre class="gmlmd">
<span class="co">/// scr_add(a, b)</span>
<span class="kw">if</span> <span class="op">(</span><a class="sf" href="#live_call">live_call</a><span class="op">(</span><span class="sv">argument0</span><span class="op">,</span> <span class="sv">argument1</span><span class="op">)</span><span class="op">)</span> <span class="kw">return</span> <a class="sv" href="#live_result">live_result</a><span class="op">;</span>
<span class="kw">return</span> <span class="sv">argument0</span> <span class="op">+</span> <span class="sv">argument1</span><span class="op">;</span>
</pre><p>If your script takes a varying number of arguments, see <a href="#live_call_ext">live_call_ext</a>.
	</p></div></div>
	<div class="item"><a class="header" id="live_call_ext" href="#live_call_ext" title="(permalink)">live_call_ext(argument_array)</a><div class="content"><p>
		Same as <a href="#live_call">live_call</a>, but allows to pass arguments as an array instead of a fixed list. You would usually use it like the following:
		<br/></p><pre class="gmlmd">
<span class="kw">var</span> <span class="lv">argument_arr</span> <span class="op">=</span> <span class="sf">array_create</span><span class="op">(</span><span class="sv">argument_count</span><span class="op">)</span><span class="op">;</span>
<span class="kw">for</span> <span class="op">(</span><span class="kw">var</span> <span class="lv">i</span> <span class="op">=</span> <span class="nu">0</span><span class="op">;</span> <span class="lv">i</span> <span class="op">&lt;</span> <span class="sv">argument_count</span><span class="op">;</span> <span class="lv">i</span><span class="op">++</span><span class="op">)</span> <span class="cb">{</span>
	<span class="lv">argument_arr</span><span class="op">[</span><span class="lv">i</span><span class="op">]</span> <span class="op">=</span> <span class="sv">argument</span><span class="op">[</span><span class="lv">i</span><span class="op">]</span><span class="op">;</span>
<span class="cb">}</span>
<span class="kw">if</span> <span class="op">(</span><a class="sf" href="#live_call_ext">live_call_ext</a><span class="op">(</span><span class="lv">argument_arr</span><span class="op">)</span><span class="op">)</span> <span class="kw">return</span> <a class="sv" href="#live_result">live_result</a><span class="op">;</span>
</pre><p>(unfortunately, GM macros do not currently allow to use <tt>argument[]</tt> / <tt>argument_count</tt> inside of them, but you can add the code as a "snippet" in GM)
	</p></div></div>
	<div class="item"><a class="header" id="live_defcall" href="#live_defcall" title="(permalink)">live_defcall(...arguments, default_value)</a><div class="content"><p>
		Same as <a href="#live_call">live_call</a> but returns <tt>default_value</tt> instead of <tt>0</tt> if execution fails.
		</p><p>
		This is handy if livecoding a script that may only return values of specific type (thus specifying a default value would allow to avoid errors outside of "live" code).
		</p><p>
		For example,
		<br/></p><pre class="gmlmd">
<span class="co">/// scr_transform_string(string)</span>
<span class="kw">if</span> <span class="op">(</span><a class="sf" href="#live_defcall">live_defcall</a><span class="op">(</span><span class="sv">argument0</span><span class="op">,</span> <span class="st">""</span><span class="op">)</span><span class="op">)</span> <span class="kw">return</span> <a class="sv" href="#live_result">live_result</a><span class="op">;</span>
<span class="co">// (some risky manipulations with string)</span>
</pre><p>would return <tt>""</tt> if execution of the "live" code fails.
	</p></div></div>
	<div class="item"><a class="header" id="live_defcall_ext" href="#live_defcall_ext" title="(permalink)">live_defcall_ext(argument_array, default_value)</a><div class="content"><p>
		A mix of <a href="#live_call_ext">live_call_ext</a> and <a href="#live_defcall">live_defcall</a> - you can both pass arguments as an array and a default return value.
	</p></div></div>
	<div class="item"><a class="header" id="live_result" href="#live_result" title="(permalink)">live_result</a><div class="content"><p>
		Stores the returned value from the last <a href="#live_call">live_call</a> (or other "live" group functions) if execution succeeded. If the code did not return anything, holds <tt>0</tt> (GM default for <tt>exit</tt>).
	</p></div></div>
</p></div></div>
<div class="item"><a class="header" id="tech" href="#tech" title="(permalink)">Technical topics</a><div class="content"><p>
	<div class="item"><a class="header" id="gmlive-server" href="#gmlive-server" title="(permalink)">gmlive-server</a><div class="content"><p>
		Is a helper application for GMLive.gml. It does a few things: </p><ul>
			<li>	Fetches resources from the project.
			</li><li>	Watches "live" files for changes.
			</li><li>	Sends updated files to the game.
		</li></ul><p>
		Starting up without arguments (such as by double-clicking the executable) has it automatically pick the GMS1/GMS2 project in the parent directory.
		</p><p>
		Passing an argument (such as by dragging a file/directory onto the executable) has it load up the specified project.
		</p><p>
		Starting up from command-line/PowerShell/terminal allows to specify additional arguments: </p><ul>
			<li>	<tt>--port &lt;port number&gt;</tt>: Sets a custom port to run the server on.
				<br/>You shouldn't need to touch this unless the default port (5100) is being used by some other application or you desire to run multiple gmlive-server instances on multiple project directories at once.
			</li><li>	<tt>--password &lt;string&gt;</tt>: Sets a custom password (to be passed in <a href="#live_init">live_init</a>).
			</li><li>	<tt>--timeout &lt;seconds&gt;</tt>: Adjusts connection timeout for clients.
				<br/>In other words, how long it is without a response before a connection is dropped and related data structures are cleaned up. Default is 60 seconds and you wouldn't usually need to touch this unless you have issues with the game disconnecting during a step-by-step debug session.
		</li></ul><p>
		On the technical side, gmlive-server is a <a href="http://nekovm.org/">Neko VM</a> application. For Windows, the few DLLs it uses and an executable version are packaged together with it. On Mac, you'll need to install Neko VM binaries (~1.5MB) to be able to run it from terminal via
		<br/></p><pre>
neko gmlive-server.n
</pre><p></p></div></div>
	<div class="item"><a class="header" id="tech-errors" href="#tech-errors" title="(permalink)">Error handling</a><div class="content"><p>
		Things that GMLive takes care of: </p><ul>
			<li>	Syntax errors in "live" code
				<br/>(code will not be updated if the new version doesn't compile)
			</li><li>	Value errors (e.g. trying to add a string to a number, dividing by 0)
			</li><li>	Missing variables/instances
			</li><li>	Wrong argument types passed to common built-in functions
		</li></ul><p>
		When a "runtime" error occurs, it is logged and the "live" script/event halts execution. This does not prevent subsequent attempts to execute the code.
		</p><p>
		Things that GMLive cannot take care of: </p><ul>
			<li>	Runtime errors in non-"live" scripts
			</li><li>	Errors thrown by built-in functions (e.g. drawing nonexistent sprites)
		</li></ul><p class="pad">
		
	</p></div></div>
</p></div></div>
<div class="item"><a class="header" id="Limitations" href="#Limitations" title="(permalink)">Limitations</a><div class="content"><p>
	<div class="item"><a class="header" id="lim-performance" href="#lim-performance" title="(permalink)">Performance</a><div class="content"><p>
		On average, any time you add another layer on interpreted code, performance degrades 5x..10x - YYC code is on average 5 times slower than equivalent handwritten C++ code, non-YYC GML is about 3..5 times slower than that, and GMLive, <abbr title="to be able to access various structures that are not exposed to native extensions">having runtime compiled to GML</abbr>, has roughly GM8.1 level of performance on non-YYC and roughly regular GMS level of performance on YYC.
		</p><p>
		This has a few implications: </p><ul>
			<li>	Enabling livecoding for too many performance-critical scripts at once isn't a good idea (although can be used to test and compare algorithms in realtime).
			</li><li>	Using GMLive for ad-hoc modding support isn't a good idea - both for performance reasons and because the interpreted scripts would have complete access to GM API and game's resources.
		</li></ul><p class="pad">
		
		That said, both GMLive and GameMaker are being worked on, thus things will likely improve as time goes on.
	</p></div></div>
	<div class="item"><a class="header" id="lim-native-ext" href="#lim-native-ext" title="(permalink)">Calling functions in native extensions</a><div class="content"><p>
		GMLive by default has entirety of standard GameMaker API and all game-specific resources exposed to it, but native extension' functions currently cannot be dynamically referenced, therefore you would not be able to call them from "live" code by default.
		</p><p>
		As a workaround, you can make a script that calls the function, and then call that script (this is also what GMLive does for built-in GM functions).
	</p></div></div>
	<div class="item"><a class="header" id="lim-array-copy" href="#lim-array-copy" title="(permalink)">Copy-on-write behaviour in arrays</a><div class="content"><p>
		GML itself has a <a href="http://docs2.yoyogames.com/source/_build/3_scripting/3_gml_overview/10_arrays.html">particular feature</a> (see "Advanced Array Functionality") that has it that passing an array as an argument to a script and then changing it via <tt>arr[index] = value</tt> rather than <tt>arr[@index] = value</tt> would clone the array prior.
		</p><p>
		The internal data for this is not exposed, however, so GMLive is unable to do it in the same way, and only does "create-on-write" (replacing a value with a new array if it isn't yet).
		</p><p>
		If this doesn't make immediate sense, it is unlikely that you rely on this feature anywhere.
	</p></div></div>
	<div class="item"><a class="header" id="lim-dyn-switch" href="#lim-dyn-switch" title="(permalink)">Dynamic expressions in switch-cases</a><div class="content"><p>
		GML itself allows to put dynamic expressions into switch' cases, meaning that you could do
		<br/></p><pre class="gmlmd">
<span class="kw">switch</span> <span class="op">(</span><span class="kw">global</span><span class="op">.</span><span class="uv">a</span><span class="op">)</span> <span class="cb">{</span>
	<span class="kw">case</span> <span class="kw">global</span><span class="op">.</span><span class="uv">b</span><span class="op">:</span> <span class="kw">return</span> <span class="st">"a == b"</span><span class="op">;</span>
	<span class="kw">case</span> <span class="kw">global</span><span class="op">.</span><span class="uv">c</span><span class="op">:</span> <span class="kw">return</span> <span class="st">"a == c"</span><span class="op">;</span>
	<span class="kw">default</span><span class="op">:</span> <span class="kw">return</span> <span class="st">"etc"</span><span class="op">;</span>
<span class="cb">}</span>
</pre><p>and it would be compiled to an equivalent of
		<br/></p><pre class="gmlmd">
<span class="kw">var</span> <span class="lv">temp</span> <span class="op">=</span> <span class="kw">global</span><span class="op">.</span><span class="uv">a</span><span class="op">;</span>
<span class="kw">if</span> <span class="op">(</span><span class="lv">temp</span> <span class="op">==</span> <span class="kw">global</span><span class="op">.</span><span class="uv">b</span><span class="op">)</span> <span class="cb">{</span>
	<span class="kw">return</span> <span class="st">"a == b"</span><span class="op">;</span>
<span class="cb">}</span> <span class="kw">else</span> <span class="kw">if</span> <span class="op">(</span><span class="lv">temp</span> <span class="op">==</span> <span class="kw">global</span><span class="op">.</span><span class="uv">c</span><span class="op">)</span> <span class="cb">{</span>
	<span class="kw">return</span> <span class="st">"a == c"</span><span class="op">;</span>
<span class="cb">}</span> <span class="kw">else</span> <span class="kw">return</span> <span class="st">"etc"</span><span class="op">;</span>
</pre><p>Needless to say, that does get a little nastier with fall-through cases, and GMLive currently may not agree to compile a "case" if it's expression cannot be computed compile-time (things like <tt>ord("A")</tt> are fine though).
	</p></div></div>
	<div class="item"><a class="header" id="lim-weird-macros" href="#lim-weird-macros" title="(permalink)">Unusual expressions in macros</a><div class="content"><p>
		GML itself, for what can be considered interesting reasons, allows to put pretty much anything into a macro, <em>except</em> for the <tt>argument</tt> variables.
		</p><p>
		This means that you can technically have a macro called <tt>ohno</tt> with value <tt>1 return "oh no"</tt>, and do
		<br/></p><pre class="gmlmd">
<span class="kw">var</span> <span class="lv">r</span> <span class="op">=</span> <span class="sv">ohno</span><span class="op">;</span>
<span class="kw">return</span> <span class="st">"ok"</span><span class="op">;</span>
</pre><p>and that would actually return "oh no" from the script while looking like a regular variable assignment.
		</p><p>
		GMS2 further expands on macro support, allowing to put entire blocks of code inside of a macros if you much desire.
		</p><p>
		GMLive currently sticks with "pure" macros, meaning that you can only put things that could have been put as a function argument in them (in other words, "values" / "expressions", rather than "statements").
		</p><p>
		If you have "unusual" macros in the project, GMLive will still work, but you will not be able to use them in "live" code.
	</p></div></div>
	<div class="item"><a class="header" id="lim-destroyed-fields" href="#lim-destroyed-fields" title="(permalink)">Variable access on destroyed instances</a><div class="content"><p>
		GML itself includes an interesting feature where calling <tt>instance_destroy()</tt> does not immediately terminate code execution for the instance - it is instantly removed from the room, but continues to partially exist until the end of the event, allowing to read and write it's variables if it's not through id-access.
		</p><p>
		GMLive can only use id-based variable access (since <tt>variable_local_</tt> functions weren't reintroduced to GMS1/2), therefore you would receive a warning if trying to do
		<br/></p><pre class="gmlmd">
<span class="sf">instance_destroy</span><span class="op">(</span><span class="op">)</span><span class="op">;</span>
<span class="co">// ...</span>
<span class="uv">some</span> <span class="op">=</span> <span class="nu">1</span><span class="op">;</span>
</pre><p>in a "live" script. The usual way of resolving this is using an <tt>exit</tt> or a <tt>return</tt> statement to terminate script execution after destroying the instance. This can also reduce other side effects if you weren't aware of the way things work before.
	</p></div></div>
</p></div></div><!--doc>-->
</div> <!-- #doc -->
<!-- doc: -->
<script>(function() {
var doc = document.getElementById("doc");
var headers = doc.getElementsByClassName("header");
//
var path = "jump.doc.state";
var state = null;
if (window.localStorage && JSON.parse) {
	state = window.localStorage.getItem(path);
	state = state ? JSON.parse(state) : { };
	if (state == null) state = { };
}
var isLocal = (location.host.indexOf("localhost") == 0);
//
function h3bind(h3) {
	var node = h3.parentNode;
	var snip = node.children[1];
	var id = h3.id || h3.textContent;
	h3.snip = snip;
	h3.doc_set = function(z) {
		if (z) node.classList.add("open"); else node.classList.remove("open");
		if (state) {
			state[id] = z;
			window.localStorage.setItem(path, JSON.stringify(state));
		}
	}
	h3.doc_hide = function() {
		this.doc_set(false);
	}
	h3.doc_show = function() {
		this.doc_set(true);
	}
	h3.onclick = function(_) {
		var seen = !node.classList.contains("open");
		h3.doc_set(seen);
		return false;
	};
}
function getHashFunc(id) {
	var node = document.getElementById(id);
	if (node == null) return null;
	return function(e) {
		while (node && node != doc) {
			if (node.classList.contains("item")) {
				node.classList.add("open");
			}
			node = node.parentElement;
		}
	};
}
(function() {
	for (var i = 0; i < headers.length; i++) h3bind(headers[i]);
	// Clicks in document expand the related section:
	var anchors = doc.getElementsByTagName("a");
	for (var i = 0; i < anchors.length; i++) {
		var anchor = anchors[i];
		if (anchor.classList.contains("header")) continue;
		var href = anchor.getAttribute("href");
		if (href[0] == "#") {
			var fn = getHashFunc(href.substr(1));
			if (!fn) {
				anchor.classList.add("broken");
				anchor.title = "(section missing)";
			} else anchor.addEventListener("click", fn);
		}
	}
})();
// Display helpers:
window.opt_none = function() {
	for (var li = 0; li < headers.length; li++) headers[li].doc_hide();
};
window.opt_list = function() {
	for (var li = 0; li < headers.length; li++) {
		var h3 = headers[li];
		if (h3.parentNode.parentNode != doc) {
			h3.doc_hide();
		} else h3.doc_show();
	}
};
window.opt_all = function() {
	for (var li = 0; li < headers.length; li++) headers[li].doc_show();
};
// Default display setting:
(function() {
	for (var li = 0; li < headers.length; li++) {
		var h3 = headers[li];
		var val = state ? state[h3.id || h3.textContent] : null;
		if (val == null) val = isLocal || h3.parentNode.parentNode == doc;
		if (val) h3.doc_show(); else h3.doc_hide();
	}
})();
//
(function() {
	var hash = document.location.hash;
	if (hash) {
		var _hash = hash.substr(1);
		getHashFunc(_hash)();
		setTimeout(function() {
			document.location.hash = hash + " ";
			setTimeout(function() {
				document.location.hash = hash;
			}, 0);
		}, 1);
	}
})();
//
doc.setAttribute("ready", "");
if (isLocal) {
	var live_js = document.createElement("script");
	live_js.src = "live.js";
	live_js.type = "text/javascript";
	document.head.appendChild(live_js);
}
})();
</script>
</body></html>
